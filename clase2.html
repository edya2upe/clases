<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Estructuras de Datos y Algoritmos II - Clase 2</title>

    <meta name="Estructuras de Datos y Algoritmos II - Clase 1">
    <meta name="author" content="Fernando Martínez">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/solarized.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
     var link = document.createElement( 'link' );
     link.rel = 'stylesheet';
     link.type = 'text/css';
     link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
     document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <link rel="stylesheet" href="css/helpers.css">

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">
      <div class="slides">
	<section>
	  <h1>
            <a href="http://edya2upe.github.io/"> Estructuras de Datos y Algoritmos II </a>
          </h1>
          <br>
          <br>
	  <h3> Clase 2 </h3>
          <br><br>
          <small style="float: left"><a href="?print-pdf">versión imprimible o pfd</a></small>          
	</section>
        
        <section>
          <h1>
            <a href="http://edya2upe.github.io/"> Estructuras de Datos y Algoritmos II </a>
          </h1>
          <br>
          <h2>
            Árboles
          </h2>
        </section>

        <section>
          <h2> Repaso</h2>
        </section>
        
        <section>
          <h3>¿Qué es una estructura de datos?</h3>
          
          <blockquote>
            &ldquo; Una estructura de datos es una forma particular de organizar la información en una computadora de manera tal que pueda se usada eficientemente. &rdquo;
            <small> Paul E. Black - "Dictionary of Algorithms and Data Structures" </small>
	  </blockquote>

          <h3>¿Qué es un algoritmo?</h3>
          <blockquote cite="ibidem" class="fragment">
            &ldquo; un algoritmo es un procedimiento computacional bien definido que toma un valor/es como entrada y produce un valor/es como salida. Es por lo tanto una secuencia de pasos que transforman una entrada en una salida. &rdquo;
	  </blockquote>
        </section>

        <section>
          <p> Inter-dependencia entre </p>
          <h3> propiedades/reglas de la estructura de datos </h3>
          <h3> y los algoritmos que permite </h3>
          <small class="fragment"> ventajas y desventajas </small>
        </section>
        
        <section>
          <h1> Árboles </h1>
        </section>

           
        <section data-background="img/clase2/labyrinth2.jpg" data-background-transition="zoom">
          <h2 class="cfff">  
            <a class="cfff" href="http://es.wikipedia.org/wiki/El_jard%C3%ADn_de_senderos_que_se_bifurcan">
              El jardin de los senderos que se bifurcan
            </a>
          </h2>
        </section>

        <section data-transition="zoom">
          <img class="full" src="img/clase2/recursion1.png">
        </section>

        <section  data-transition="zoom">
          <img class="full" src="img/clase2/recursion2.png">
        </section>

        <section  data-transition="zoom">
          <img class="full" src="img/clase2/recursion3.png">
        </section>

        <section  data-transition="zoom">
          <img class="full" src="img/clase2/recursion4.png">
        </section>

        <section  data-transition="zoom">
          <img class="full" src="img/clase2/recursion5.png">
        </section>

        <section data-background="img/clase2/recurrencia.jpg"  data-background-transition="zoom">
          <h3 class="fragment fborder cfff" > Recurrencia, recursión o recursividad es la forma en la cual se especifica un proceso basado en su propia definición. </h3>
          <br><br><br><br><br><br><br>
          <h1 class="cfff"> &nbsp; &nbsp; Recursión</h1>
        </section>

        <section>
          <h1>Definición</h1>
          <p> Es una <b>colección</b> de nodos, tal que: </p>
          <ul>
            <li>puede estar vacía </li>
            <li>o puede estar formada por un nodo (raíz) y otros dos árboles T1 y T2, dónde la
              raíz de cada árbol Ti está conectado a R por medio de una arista.
            </li>
          </ul>
          <br>
          <br>
          <br>
          <small> <a href="https://en.wikipedia.org/wiki/List_of_data_structures#Trees"> https://en.wikipedia.org/wiki/List_of_data_structures#Trees </a> </small>
        </section>

        <section>
          <h1> Términos </h1>

          <section>
            <p>  nodo, arista, raíz, hoja, subárbol </p>
          </section>

          <section>
            <p>  padre, hijos, hermanos </p>
          </section>
          
          <section>
            <h3>  camino  </h3>
            <p>
              desde n1 hasta n k , es una secuencia de
              nodos n 1 , n 2 , ....,n k tal que n i es el padre de n i+1 ,
              para 1 ≤ i < k.
            </p>

            <p> La longitud del camino es el número
              de aristas, es decir k-1. Existe un camino de
              longitud cero desde cada nodo a sí mismo. Existe
              un único camino desde la raíz a cada nodo
            </p>
          </section>

          <section>
            <h3>  profundidad de un nodo </h3>
            <p> Es la longitud del único camino desde la raíz hasta el nodo.</p>
            <p> La raíz tiene profundidad cero.  </p>
          </section>
          
          <section>
            <h3>  altura de un nodo </h3>
            <p> longitud del camino más largo desde el nodo hasta una hoja.
              <p> Las hojas tienen altura cero. </p>
              <p> La altura de un árbol es la altura del nodo raíz.</p>
          </section>
          
          <section>
            <h3> Grado de un nodo: </h3>
            <p>  es el número de hijos del nodo </p>
          </section>
          
          <section>
            <h3> Ancestros y Descendientes  </h3>
            <p> N1 es ancestro de N2 y N2 es descendiente de N1, si existe un camino desde N1 a N2 </p>
          </section>
        </section>

        <section>
          <h1> Aplicaciones </h1>
          <p> Árboles binarios de búsqueda</p>
          <p> Árboles de expresión </p>
        </section>

        <section>
          <h2>Árboles binarios de búsqueda </h2>
          <img class="center" src="img/clase2/arbol_busqueda.png">
        </section>

        <section>
          <h2> Árboles de expresión </h2>
          <pre>

                          a * b + c
    
    
                          a * ( b + c )
          </pre>
          </p>
        </section>

        <section>
          <p>
            a   *   ( ( b * d ) + c ) )   +   ( e + ( f * g ) )
          </p>
          <img  class="center fragment" src="img/clase2/arbol_exp.png">
        </section>

        <section>
          <h1>Recorridos</h1>
          <p>  En profundidad (DFS): inorden, preorden, postorden </p>
          <p>  por niveles (BFS) </p>
        </section>

        <section>
          <h3>preorden</h3>
          <pre><code class="markdown">
            1. proceso la raiz
            2. Si tengo hijo izquierdo, recorro el subarbol izquierdo
            3. Si tengo hijo derecho, recorro el subarbol derecho
          </code></pre>
        </section>

        <section>
          <h3>inorden</h3>
          <pre><code class="markdown">
            1. Si tengo subarbol izquierdo, recorro el subarbol izquierdo
            2. proceso la raíz
            3. Si tengo subarbol derecho, recorro el subarbol derecho
          </code></pre>
        </section>

        <section>
          <h3>postorden</h3>
          <pre><code class="markdown">
            1. Si tengo subarbol izquierdo, recorro el subarbol izquierdo
            2. Si tengo subarbol derecho, recorro el subarbol derecho
            3. proceso la raíz
          </code></pre>
        </section>

        <section>
          <h3>  Por niveles (BFS) </h3>
          <p class="fragment"> utilizamos estructura auxiliar... </p>
          <pre class="fragment" style="box-shadow: none">
            <code class="python">
              encolar raíz
              mientras haya nodos en la cola:
              desencolo un nodo
              proceso el nodo
              si tiene hijo izquierdo, encolo hijo izquierdo
              si tiene hijo derecho, encolo hijo derecho
            </code>
          </pre>
        </section>

        <section>
          <h3>  Por niveles (con marca de fin de nivel)</h3>
          <p class="fragment"> utilizamos estructura auxiliar... </p>
          <pre class="fragment" style="box-shadow: none">
            <code class="python">
              1. encolar raíz
              2. encolar marca de fin de nivel
              3. mientras la cola no sea vacía:
              3.1 desencolo un elemento
              3.2 mientras elemento no sea fin de nivel
              3.2.1 proceso el nodo
              3.2.2 si tiene hijo izquierdo, encolo hijo izquierdo
              3.2.3 si tiene hijo derecho, encolo hijo derecho
              3.2.4 desencolo un elemento
              3.3 si la cola no es vacía, encolo marca de fin de nivel
            </code>
          </pre>
        </section>


        <section>
          <h1> Tiempo de Ejecución </h1>
        </section>
        
        <section> <h1> Repaso </h1> </section>

        <section>
          <p>
            Cuando intentamos encontrar la complejidad de un algoritmo, no nos interesa el número exacto de las operaciones realizadas, Sino la relación entre el número de operaciones y el tamaño del problema a medida que el tamaño crece.
          </p>
          <p>
            Y nos interesa sobre todod el peor caso, es decir el número máximo de operaciones posibles para un tamaño determinado.
          </p>
        </section>

        <section>
          <h4> caso 1: operación Stack.pop() </h4>
          <p> ¿cómo es la relación entre cantidad de operaciones y el tamaño de la pila? </p>
          <br>
          <p class="fragment"> Constante o de Orden(1)</p>
          <small class="fragment"> siempre tarda lo mismo, independientemente de cuantos elementos haya en la pila </small>
        </section>

        <section>
          <h4> caso 2: búsqueda en una lista simple </h4>
          <p> ¿Cómo es la relación entre cantidad de operaciones y el tamaño de la lista? </p>
          <br>
          <p class="fragment"> Lineal o de Orden(N)</p>
          <small class="fragment"> cuando la cantidad de elementos de la lista crece, la cantidad de operaciones básicas crece de manera proporcional a N  (si con un elemento se requiren 5 operaciones, con 2 van a ser 10, con 3 => 15, con 4 => 20, ... , N => 5N)</small>
        </section>

        <section>
          <h4> caso 3: búsqueda binaria en una lista</h4>
          <p> ¿cómo es la relación entre cantidad de operaciones y el tamaño del árbol? </p>
          <br>
          <p class="fragment"> Logarítmica o de Orden log(N)</p>
          <small class="fragment"> cuando la cantidad de elementos de la lista crece, la cantidad de operaciones básicas crece en proporción al logaritmo de N. (si para 1 elemento se requiren 2 op, 16 elementos => 2*4 op, 32 => 2*5, 64 => 2*6, ... N => 2*log(N) )</small>
        </section>

        <section>
          <h3>Funciones características</h3>
          <img class="full" src="img/clase4/funciones-caracteristicas.png">
        </section>


        <section>
          <h1> Big-O </h1>
          <p>
            Notación formal para expresar con precisión esa relación
          </p>
        </section>

        <section>
          <small> Primero... </small>
          <h2>
            ¿qué es <b> T(n) </b>
          </h2>
          <p class="fragment"> 
            una <b>función</b>
          </p>
        </section>
        <section>
          <h2> ¿y una función? </h2>
          <p class="fragment">
            una asociación un valor de entrada con uno de salida
          </p>
        </section>
        <section>
          <h3> ahora... </h3>
          <p> n, log(n), n², <b>¿Son valores?</b></p>
          <br>
          <p class="fragment"> 
            NO, son funciones.
            <br>
            Por lo tanto, <em>T(n)</em> es una funcion que devuelve una funcion!
            <small> (higher order function, o función de orden superior) </small>
        </section>

        <section>
          <h2>Big O</h2>
          <small>definición:</small>
          <br>
          <p>
            Una función T(N) es O(f(N)) si existen las constantes C y n0 tal que:
            <br>
            <br>
            <h3>  T(N) <= C * f(N) </h3>
            <br>
            para todo N >= n0
          </p>
          <br>
          <p> <small>Se lee:</small> T de N es de Orden F de N </p>
        </section>

        <section>
          <h1> ¿Quéééé?</h1>
        </section>
        <section>
          <h2> ¿Qué significa? </h2>
          <ol> 
            <li>Que la complejidad exacta de un algoritmo, es función del tamaño del problema ( T(N) )</li>
            <li> Y que f(N) es una <b>cota superior</b> de dicha complejidad. Es decir, que en el <b> peor caso </b>, la complejidad del algoritmo nunca va a ser mayor que f(N).</li>
          </ol>
          <br>
          <br>
          <small> La forma más fácil de entenderlo es ponerle números a las constantes y a F(n) </small>
        </section>


        <section>
          <section>
            <h2> T(N) y Recursión </h2>
          </section>

          <section>
            <pre><code class="python">
            def potencia(x, n):
              if(n == 0):
                return 1
              else:
                return x * potencia(x, n-1)
            </code></pre>
          </section>

          <section>
            <h3> Pasos </h3>
            1. Identificar T(n) para el caso base
            <br>
            2. Encontrar la expresión genéral de la recursión
            <br>
            3. Reemplazar T(N) del caso base en la expresión general
          </section>

          <section>
            <ol>
              <li>t(0) = O(1)</li>
              <li>t(n) = t(n-1) + 2</li>
            </ol>
            <pre>

            t(n-1) = t(n-2) + 2
            </pre>
          </section>
          <section>
            <pre>
          reemplazamos t(n-1) en 1.
            
          t(n) = [  t(n-1)  ] + 2
          t(n) = [t(n-2) + 2] + 2
            </pre>
          </section>

          <section>
            <pre>
                t(n-2) = t(n-3) + 2
      
                t(n) = [  t(n-2)  ] + 2 + 2
                t(n) = [  t(n-2)  ] + 2 + 2
      
                t(n) = [t(n-3) + 2] + 2 + 2
                t(n) = t(n-3) + 2*3
                
                t(n-3) = [t(n-4) + 2]
      
              t(n) = t(n-4) + 2 + 3*2
              t(n) = t(n-4) + 4*2
            </pre>
          </section>
          <section>
            <h2> en general </h2>
            <pre>
              t(n) = t(n-i) + 2 * i
            </pre>
          </section>
          <section>
            <ol>
              <li>t(0) = O(1)</li>
              <li>t(n) = t(n-i) + 2*i</li>
            </ol>
            <br>
            <br>
            <small>
              ya sabemos que T(0) es 1
              <br>
              ¿Qué valor debería tener n, para que t(n-i) sea t(0)?
              <br>
            </small>
            
          </section>
          <section>
            Igualamos (n - i) = 0 y despejamos i
            <pre>
              n - i = 0
            
              # si despejamos i
              
              i = n
              
              # reemplazamos i en la expresión general de la recurrencia:
              t(n) = t(n-i) + 2 * i
              t(n) = t(n - n) + 2 * n
              t(n) = t(0) + 2*n
              t(n) = 1 + 2*n
              
              T(n) = O(n)
            </pre>
          </section>
          <section>

            En la página tienen disponible un 
            <a href="http://edya2upe.github.io/public/files/fuente_tiempoDeEjecucion.zip"> <b> Apunte </b> </a>
            con las explicaciones prácticas acerca del cálculo de T(n) iterativo y recurrente.
            
          </section>
        </section>
        <section>
          <h2> Algunas referencias </h2>
          <a href="http://web.mit.edu/16.070/www/lecture/big_o.pdf"> http://web.mit.edu/16.070/www/lecture/big_o.pdf </a>
          <a href="http://courses.csail.mit.edu/6.01/spring07/lectures/lecture4.pdf"> http://courses.csail.mit.edu/6.01/spring07/lectures/lecture4.pdf </a>
          <a href="http://www.lab.dit.upm.es/~lprg/material/apuntes/o/#s2"> http://www.lab.dit.upm.es/~lprg/material/apuntes/o/#s2 </a>
          <a href="http://en.wikipedia.org/wiki/Big_O_notation"> http://en.wikipedia.org/wiki/Big_O_notation </a>
          <a href="http://www.cs.ucf.edu/~dmarino/ucf/cop3502/lec_biswas/recursion12.pdf"> http://www.cs.ucf.edu/~dmarino/ucf/cop3502/lec_biswas/recursion12.pdf </a>
        </section>


        <section>
          <h1>Fin</h1>
          <p class="fragment">
            ¿Preguntas?
          </p>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script>

     // Full list of configuration options available at:
     // https://github.com/hakimel/reveal.js#configuration
     Reveal.initialize({
       progress: true,
       history: true,
       center: true,
       keyboard: true,

       transition: 'slide', // none/fade/slide/convex/concave/zoom

       // Optional reveal.js plugins
       dependencies: [
	 { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
	 { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
	 { src: 'plugin/zoom-js/zoom.js', async: true },
	 { src: 'plugin/notes/notes.js', async: true }
       ]
     });
    </script>

  </body>
</html>
